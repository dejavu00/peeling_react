<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue响应原理</title>
</head>
<body>
<div>
MVVM是Model-View-ViewModel的缩写。
<p>Model ：代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</p>
<p>View ：代表UI组件，它负责将数据模型转化成UI展现出来。</p>
<p>ViewModel ：监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View和Model的对象，连接Model和View。
</p>
<p>在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的， 因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上。
</p>
<p>ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和 Model之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。
</p>



    <p>   vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
    </p>
    具体步骤：

    <p>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
        这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>

    <p>    第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
    </p>
    <p>
        第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
        1、在自身实例化时往属性订阅器(dep)里面添加自己
        2、自身必须有一个update()方法
        3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

    </p>
    <p>    第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
    </p>
</div>
<div id="update">
    {{name}}
</div>
<script>
	function observe(obj) {
		// 判断类型
		if (!obj || typeof obj !== 'object') {
			return
		}
		Object.keys(obj).forEach(key => {
			defineReactive(obj, key, obj[key])
		})
	}

	function defineReactive(obj, key, val) {
		// 递归子属性
		observe(val)
		let dp = new Dep()
		Object.defineProperty(obj, key, {
			enumerable: true,
			configurable: true,
			get: function reactiveGetter() {
				console.log('get value')
				// 将 Watcher 添加到订阅
				if (Dep.target) {
					dp.addSub(Dep.target)
				}
				return val
			},
			set: function reactiveSetter(newVal) {
				console.log('change value')
				val = newVal
				// 执行 watcher 的 update 方法
				dp.notify()
			}
		})
	}
	// 通过 Dep 解耦
	class Dep {
		constructor() {
			this.subs = []
		}
		addSub(sub) {
			// sub 是 Watcher 实例
			this.subs.push(sub)
		}
		notify() {
			this.subs.forEach(sub => {
				sub.update()
			})
		}
	}
	// 全局属性，通过该属性配置 Watcher
	Dep.target = null


	class Watcher {
		constructor(obj, key, cb) {
			// 将 Dep.target 指向自己
			// 然后触发属性的 getter 添加监听
			// 最后将 Dep.target 置空
			Dep.target = this
			this.cb = cb
			this.obj = obj
			this.key = key
			this.value = obj[key]
			Dep.target = null
		}
		update() {
			// 获得新值
			this.value = this.obj[this.key]
			// 调用 update 方法更新 Dom
			this.cb(this.value)
		}
	}
	var data = { name: 'yck' }
	observe(data)
	console.log(data);
	// 模拟解析到 `{{name}}` 触发的操作
	new Watcher(data, 'name', update)
	// update Dom innerText
	data.name = 'Dejavu'

	function update(value) {
		document.querySelector('#update').innerText = value
	}

</script>
</body>
</html>
